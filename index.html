<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Chatroom</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
/* Base Styling */
body {
    margin: 0;
    font-family: 'Inter', sans-serif;
    background: #0b1225;
    color: white;
    display: flex;
    flex-direction: column;
    height: 100vh; 
}
/* App container now takes full width and height */
#app-container {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%; 
    flex-grow: 1; 
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    background: #081023;
}
header {
    position: relative; 
    padding: 12px 16px;
    text-align: center;
    background: #10193a;
    font-size: 20px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    display: flex; 
    justify-content: space-between;
    align-items: center;
}
header > span {
    flex-grow: 1;
    text-align: center;
}
/* New UI elements in Header */
#status-info {
    font-size: 14px;
    font-weight: normal;
    display: flex;
    gap: 15px;
    align-items: center;
}
#online-count, #room-user-count {
    display: flex;
    align-items: center;
    gap: 4px;
    color: #00e6b1;
}
#online-count i, #room-user-count i {
    color: #ff5722;
}

/* NEW STYLING FOR SECRET BUTTON (REMAINS TINY) */
#secret-admin-button {
    position: absolute;
    top: 0;
    left: 0;
    width: 12px; 
    height: 12px;
    cursor: pointer;
    background: transparent;
    z-index: 20; 
}

/* Room Control Styling */
#room-controls {
    padding: 10px;
    background: #1f2d57;
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}
#room-controls input {
    padding: 8px;
    border: none;
    border-radius: 6px;
    background: #10193a;
    color: white;
    outline: none;
    flex-grow: 1;
}
#room-controls button {
    background: #ff5722;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 8px 12px;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s;
    white-space: nowrap;
}
#room-controls button:hover {
    background: #e64a19;
}
#current-room-display {
    font-size: 14px;
    font-weight: 500;
    color: #00e6b1;
    white-space: nowrap;
}
#user-list-toggle, #commands-toggle-btn {
    background: #10193a;
    color: #00e6b1;
    border: none;
    border-radius: 6px;
    padding: 8px 12px;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s;
}
#user-list-toggle:hover, #commands-toggle-btn:hover {
    background: #1f2d57;
}

/* Chat Area and Layout */
#main-content {
    display: flex;
    flex-grow: 1;
    overflow: hidden;
    position: relative;
}
#chat-container {
    flex-grow: 1;
    overflow: hidden;
    position: relative; 
    display: flex;
    flex-direction: column;
}
#chat {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    scroll-behavior: smooth;
}
.msg {
    display: flex;
    align-items: flex-start;
    margin-bottom: 15px;
    opacity: 0.95;
    transition: opacity 0.3s ease;
    position: relative;
    gap: 5px; 
}
.msg.me {
    justify-content: flex-end;
}
.name {
    font-size: 11px;
    color: #a0a0a0;
    margin-bottom: 3px;
}
/* Styling for private message names */
.whisper-name {
    color: #ffb74d; /* Orange/Gold color */
    font-weight: bold;
}
.bubble-wrapper {
    max-width: 80%;
    display: flex;
    flex-direction: column;
}
.bubble {
    background: #1f2d57;
    padding: 10px 14px;
    border-radius: 18px;
    display: inline-block;
    word-wrap: break-word;
    white-space: pre-wrap;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.me .bubble {
    background: #00e6b1;
    color: #10193a;
    border-bottom-right-radius: 4px;
}
/* NEW: Private Message Bubble Style */
.msg.private .bubble {
    background: #3a3a10; /* Dark Gold/Brown background */
    border: 1px solid #ffd700;
}
.msg.private.me .bubble {
    background: #575700;
    color: white;
}
.msg:not(.me) .bubble {
    border-bottom-left-radius: 4px;
}

/* Correctly order the bubble and action buttons for 'me' messages */
.me .bubble-wrapper {
    align-items: flex-end; /* Align name and bubble to the right */
    order: 1; 
}
.me .action-buttons {
    order: 0; /* Ensures buttons are on the right (before wrapper) in a flex-end container */
}
.msg:not(.me) .action-buttons {
    order: 1;
}
.msg:not(.me) .bubble-wrapper {
    order: 0;
}


/* Input Area and Controls */
#input-wrapper {
    padding: 10px;
    background: #081023;
    border-top: 1px solid #1f2d57;
    position: relative;
    flex-shrink: 0; 
}
#typing-indicator {
    height: 18px;
    font-size: 12px;
    color: #00e6b1;
    margin-bottom: 4px;
    overflow: hidden;
    white-space: nowrap;
}
#input {
    display: flex;
    align-items: center;
    gap: 8px;
}
#input input {
    padding: 12px;
    border: none;
    border-radius: 8px;
    background: #1f2d57;
    color: white;
    outline: none;
    flex: 1; /* Message input takes all space */
    font-size: 16px;
}

#input .action-button {
    background: #00e6b1;
    color: #0b1225;
    border: none;
    border-radius: 8px;
    padding: 12px 18px;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
}
#input .action-button:hover {
    background: #00c99a;
}
#input .action-button:active {
    transform: scale(0.98);
}
/* Command Button Specific Styling */
#commands-toggle-btn {
    background: #1f2d57;
    color: #ffd700;
}
#commands-toggle-btn:hover {
    background: #2a3a69;
}


/* Emoji Panel Styling (Unchanged) */
#emoji-toggle-btn {
    background: #1f2d57;
    color: #ffd700;
    font-size: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0; 
    width: 44px;
    height: 44px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    line-height: 1;
    transition: background 0.2s;
}
#emoji-toggle-btn:hover {
    background: #2a3a69;
}
#emoji-panel {
    display: none;
    position: absolute;
    bottom: 64px; 
    left: 0;
    right: 0;
    max-height: 200px;
    background: #10193a;
    padding: 10px;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    box-shadow: 0 -5px 15px rgba(0,0,0,0.3);
    overflow-y: auto;
    z-index: 10;
}
#emoji-panel.active {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
    gap: 5px;
}
.emoji {
    font-size: 24px;
    text-align: center;
    cursor: pointer;
    padding: 5px;
    border-radius: 6px;
    transition: background 0.1s;
}
.emoji:hover {
    background: #1f2d57;
}

/* Admin Panel Styling (Unchanged) */
#admin-banner {
    position: sticky;
    top: 0;
    background-color: #e63946;
    color: white;
    padding: 8px 15px;
    text-align: center;
    font-weight: bold;
    z-index: 5;
    display: none;
    animation: fadeIn 0.3s ease-out;
    box-shadow: 0 3px 5px rgba(0,0,0,0.2);
}
#admin-banner button { /* Styling for Clear All Messages button */
    background: #a82733;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 5px 10px;
    margin-left: 15px;
    cursor: pointer;
    font-weight: normal;
    transition: background 0.2s;
}
#admin-banner button:hover {
    background: #8a1f29;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* ACTION BUTTON STYLES (Visibility controlled by opacity/hover) */
.action-btn {
    background: #1f2d57;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 10px;
    cursor: pointer;
    transition: background 0.2s;
    flex-shrink: 0;
    opacity: 0; 
    transition: opacity 0.3s ease;
    pointer-events: none; 
    margin-right: 5px; 
}

.delete-btn {
    background: #e63946;
}
.delete-btn:hover {
    background: #cc2936;
}

/* Edit button styling */
.edit-btn {
    background: #2a7e78; 
}
.edit-btn:hover {
    background: #21635e;
}

/* Show buttons on message hover */
.msg:hover .action-buttons .action-btn {
    opacity: 1;
    pointer-events: auto; 
}

/* Always show buttons for admin mode messages and 'me' messages */
.msg.admin .action-buttons .action-btn,
.msg.me .action-buttons .action-btn {
    opacity: 1;
    pointer-events: auto;
}

/* User List Sidebar Styling */
#user-list-container {
    width: 0;
    background: #10193a;
    border-left: 1px solid #1f2d57;
    transition: width 0.3s ease-in-out;
    overflow: hidden;
    flex-shrink: 0;
    padding-bottom: 0; 
    height: 100%;
    display: flex;
    flex-direction: column;
}
#user-list-container.active {
    width: 200px; 
}
#user-list-header {
    padding: 10px;
    font-weight: bold;
    border-bottom: 1px solid #1f2d57;
    background: #1f2d57;
    text-align: center;
    flex-shrink: 0; 
}
#user-list {
    padding: 10px;
    overflow-y: auto;
    flex-grow: 1; 
}
.user-item {
    padding: 6px 0;
    font-size: 14px;
    color: #a0a0a0;
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 500;
}
.user-item i {
    color: #00e6b1; 
    font-size: 8px;
}

/* Styling for Muted Users in the List */
.user-item.muted-user {
    color: #e63946; 
    font-weight: bold;
}
.user-item.muted-user i {
    color: #e63946;
}

/* Media query for smaller screens: Hide user list toggle */
@media (max-width: 600px) {
    #user-list-toggle {
        display: none;
    }
    #user-list-container.active {
        position: absolute;
        right: 0;
        top: 0;
        height: 100%;
        z-index: 100;
        width: 70%;
    }
}

/* USERNAME MODAL STYLING (Unchanged) */
#username-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}
#username-modal {
    background: #10193a;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    text-align: center;
    max-width: 400px;
    width: 90%;
}
#username-modal h2 {
    margin-top: 0;
    color: #00e6b1;
}
#username-modal input {
    width: 100%;
    padding: 12px;
    margin: 15px 0 20px 0;
    border: 1px solid #1f2d57;
    border-radius: 6px;
    background: #1f2d57;
    color: white;
    box-sizing: border-box;
    font-size: 16px;
    outline: none;
}
#username-modal button {
    background: #ff5722;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 10px 20px;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s;
}
#username-modal button:hover {
    background: #e64a19;
}

/* COMMANDS MODAL STYLING (NEW) */
#commands-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none; /* Hidden by default */
    justify-content: center;
    align-items: center;
    z-index: 2000;
}
#commands-modal {
    background: #10193a;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    max-width: 500px;
    width: 90%;
}
#commands-modal h2 {
    margin-top: 0;
    color: #00e6b1;
    border-bottom: 1px solid #1f2d57;
    padding-bottom: 10px;
}
#commands-modal p {
    color: #a0a0a0;
    margin-bottom: 20px;
}
#commands-modal code {
    background: #1f2d57;
    padding: 3px 6px;
    border-radius: 4px;
    color: #ffd700;
    font-weight: bold;
}
.command-item {
    margin-bottom: 15px;
    border-left: 3px solid #00e6b1;
    padding-left: 10px;
}

/* Edit Input Field Styling (Unchanged) */
.edit-input-wrapper {
    background: #1f2d57;
    padding: 10px;
    border-radius: 12px;
    margin-top: 5px;
    display: none; /* Hide by default */
    gap: 5px;
    align-items: center;
}

.edit-input-wrapper input {
    flex-grow: 1;
    padding: 8px;
    border: none;
    border-radius: 6px;
    background: #081023;
    color: white;
    outline: none;
}

.edit-input-wrapper button {
    background: #00e6b1;
    color: #10193a;
    border: none;
    border-radius: 6px;
    padding: 8px 12px;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s;
    white-space: nowrap;
}

.edit-input-wrapper button:hover {
    background: #00c99a;
}
/* NEW: Clear Confirmation Modal Styles */
#clear-confirm-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none; 
    justify-content: center;
    align-items: center;
    z-index: 2001; /* Higher z-index */
}
#clear-confirm-modal {
    background: #10193a;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    text-align: center;
    max-width: 400px;
    width: 90%;
    border: 2px solid #e63946;
}
#clear-confirm-modal h2 {
    margin-top: 0;
    color: #e63946;
}
#clear-confirm-modal button {
    margin: 0 10px;
    padding: 10px 20px;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s;
}
#clear-confirm-modal button.confirm {
    background: #e63946;
    color: white;
    border: none;
}
#clear-confirm-modal button.cancel {
    background: #1f2d57;
    color: white;
    border: none;
}
</style>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

</head>

<body>
<div id="app-container">
    <header>
        <div id="status-info">
            <div id="online-count" title="Total Online Users">
                <i class="fas fa-globe"></i>
                <span id="total-online-val">0</span>
            </div>
             <div id="room-user-count" title="Users in this Room">
                <i class="fas fa-users"></i>
                <span id="room-user-val">0</span>
            </div>
        </div>
        
        <span>Chatroom</span>
        
        <div id="secret-admin-button" onclick="toggleAdminMode()"></div>
    </header>

    <div id="room-controls">
        <span id="current-room-display">Room: #global</span>
        <input id="room-code-input" placeholder="Enter Room Code">
        <button onclick="joinRoom()">Join/Create Room</button>
        <button id="user-list-toggle" onclick="toggleUserList()">Users</button>
    </div>

    <div id="main-content">
        <div id="chat-container">
            <div id="admin-banner">
                ADMIN MODE ACTIVE! (Click the top-left corner to toggle off)
                <button id="clear-chat-btn" onclick="showConfirmClear()">Clear All Messages</button>
            </div>
            <div id="chat">
                 </div>
        </div>
        
        <div id="user-list-container">
            <div id="user-list-header">Users in #<span id="room-id-header">global</span></div>
            <div id="user-list">
                 </div>
        </div>
    </div>

    <div id="input-wrapper">
        <div id="emoji-panel">
                 </div>
        
        <div id="typing-indicator"></div>

        <div id="input">
            <button id="commands-toggle-btn" class="action-button" onclick="toggleCommandsModal()" title="View Chat Commands">?</button>
            <input id="message" placeholder="Message" onkeydown="handleInputKey(event)">
            <button id="emoji-toggle-btn" onclick="toggleEmojiPanel()">&#x1F60A;</button>
            <button class="action-button" onclick="send()">Send</button>
        </div>
            </div>
</div>

<div id="username-modal-overlay" style="display: none;">
    <div id="username-modal">
        <h2>Welcome to the Chatroom</h2>
        <p>Please enter a username to start chatting.</p>
        <input type="text" id="username-input" placeholder="Enter your name" onkeydown="if(event.key==='Enter') saveUsername()">
        <button onclick="saveUsername()">Join Chat</button>
    </div>
</div>

<div id="commands-modal-overlay">
    <div id="commands-modal">
        <h2>Chat Commands</h2>
        <p>Use these commands in the message box:</p>
        <div class="command-item">
            <strong>Private Message (Whisper)</strong>
            <p>Send a message only visible to you and the target user.</p>
            <code>/whisper "Username" Your private message here.</code>
            <p style="font-size: 0.9em; margin-top: 5px;">*The username must match exactly (case-sensitive).</p>
        </div>
        <button class="action-button" onclick="toggleCommandsModal()" style="background: #ff5722; color: white;">Close</button>
    </div>
</div>

<div id="clear-confirm-modal-overlay">
    <div id="clear-confirm-modal">
        <h2>‚ö†Ô∏è Confirm Clear Chat</h2>
        <p>Are you sure you want to delete **ALL** messages in room #<span id="clear-room-name">global</span>?</p>
        <button class="cancel" onclick="document.getElementById('clear-confirm-modal-overlay').style.display = 'none'">Cancel</button>
        <button class="confirm" onclick="confirmClear()">Clear All</button>
    </div>
</div>

<script>
/* üî• PASTE YOUR FIREBASE CONFIG BELOW */
const firebaseConfig = {
    apiKey: "AIzaSyB_GfRwg6BuASa8h1a9tetH9lrqonpJlRs",
    authDomain: "chat-app-54184.firebaseapp.com",
    databaseURL: "https://chat-app-54184-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "chat-app-54184",
    storageBucket: "chat-app-54184.firebasestorage.app",
    messagingSenderId: "868476806722",
    appId: "1:868476806722:web:b877f501dd4b377adb2fdb",
    measurementId: "G-FLMZEKWDNH"
};
/* -------------------------------- */

firebase.initializeApp(firebaseConfig);

const chat = document.getElementById("chat");
const messageInput = document.getElementById("message");
let userName = null;
const adminBanner = document.getElementById("admin-banner");
const emojiPanel = document.getElementById("emoji-panel");
const roomInput = document.getElementById("room-code-input");
const roomDisplay = document.getElementById("current-room-display");
const typingIndicator = document.getElementById("typing-indicator");
const totalOnlineVal = document.getElementById("total-online-val");
const roomUserVal = document.getElementById("room-user-val");
const userList = document.getElementById("user-list");
const userListContainer = document.getElementById("user-list-container");
const roomIdHeader = document.getElementById("room-id-header");
const usernameModalOverlay = document.getElementById('username-modal-overlay');
const usernameInput = document.getElementById('username-input');
// NEW Command Modal
const commandsModalOverlay = document.getElementById('commands-modal-overlay');
// NEW Clear Modal
const clearConfirmModalOverlay = document.getElementById('clear-confirm-modal-overlay');
const clearRoomNameSpan = document.getElementById('clear-room-name');


// üî• NEW SECURE VARIABLES üî•
const ADMIN_UID = "QWU9sIKeNVgOwSA9qrjG85IJ6Ww1"; 

let userId = null; 
let isAdmin = false; 

let currentRoomId = 'global';
let currentRoomRef = null;
let chatListener = null; 
let chatEditListener = null; 
let roomPresenceListener = null; 
let typingListener = null; 

// üî• NEW: User Map for Whisper Command
let userMap = {}; // { "username": "UID" }

// Firebase References
const db = firebase.database(); 
const auth = firebase.auth(); 
const totalOnlineRef = db.ref('online'); 
const typingRef = db.ref('typing'); 
const privateMessageRef = db.ref('privateMessages'); // NEW: Dedicated ref for whispers

// MESSAGE LIMIT, MUTE FEATURE, AND RATE LIMITING (Unchanged)
const MAX_MESSAGE_LENGTH = 500; 
const MUTED_USERS_REF = db.ref('mutedUsers'); 
let mutedUserIds = {}; 
const MESSAGE_HISTORY = {}; 
const MAX_MESSAGES_IN_WINDOW = 4; 
const TIME_WINDOW_MS = 10000; 

function checkRateLimit() {
    // ... (unchanged logic) ...
     if (!MESSAGE_HISTORY[userId]) {
         MESSAGE_HISTORY[userId] = [];
    }

    const now = Date.now();
    const history = MESSAGE_HISTORY[userId];

    const newHistory = history.filter(time => now - time < TIME_WINDOW_MS);
    newHistory.push(now);
    MESSAGE_HISTORY[userId] = newHistory;

    if (newHistory.length > MAX_MESSAGES_IN_WINDOW) {
        newHistory.pop();
        console.warn(`Rate limit exceeded for user ${userId}. History length: ${newHistory.length}`);
        return true;
    }

    return false;
}


// --- USERNAME & COMMAND MODAL LOGIC ---

function showNameModal() {
    usernameModalOverlay.style.display = 'flex';
    usernameInput.focus();
}

function saveUsername() {
    const inputName = usernameInput.value.trim();
    if (inputName.length < 2 || inputName.length > 20) {
        alert("Please enter a username between 2 and 20 characters.");
        usernameInput.focus();
        return;
    }
    
    userName = inputName;
    usernameModalOverlay.style.display = 'none';
    
    finishInitialization();
}

/**
 * Toggles the visibility of the user commands modal.
 */
function toggleCommandsModal() {
    const isVisible = commandsModalOverlay.style.display === 'flex';
    commandsModalOverlay.style.display = isVisible ? 'none' : 'flex';
}

function finishInitialization() {
    isAdmin = (userId === ADMIN_UID);
    if(isAdmin) console.log("Admin privileges confirmed.");

    populateEmojis(); 
    setupRoomConnection(currentRoomId); 
    setupGlobalListeners();
    setupPrivateMessageListener(); // NEW
    if(isAdmin) {
        // Only show the banner if already in admin mode upon init
        adminBanner.style.display = 'flex';
    }
}

// --- AUTHENTICATION AND PRESENCE LOGIC ---

function setupAuthAndInit() {
    auth.signInAnonymously()
        .then((userCredential) => {
            userId = userCredential.user.uid;
            console.log("Authenticated as:", userId);
            showNameModal(); 

        })
        .catch((error) => {
            console.error("Anonymous authentication failed:", error);
            console.error("Chat failed to load: Could not authenticate.");
        });
}

function setupPresence() {
    if (!userId || !userName) return; 

    const userRef = totalOnlineRef.child(userId);
    userRef.onDisconnect().remove();

    userRef.set({
        name: userName,
        room: currentRoomId,
        time: firebase.database.ServerValue.TIMESTAMP
    });
}

function setupGlobalListeners() {
    // 1. Total Online Count (Unchanged)
    totalOnlineRef.on('value', snapshot => {
        const count = snapshot.numChildren();
        totalOnlineVal.textContent = count;
    });

    // 2. Typing Indicator Listener (Unchanged setup)
    if (typingListener) typingRef.child(currentRoomId).off('value', typingListener);

    typingListener = typingRef.child(currentRoomId).on('value', snapshot => {
        const typers = [];
        snapshot.forEach(child => {
            if (child.key !== userId) {
                typers.push(child.val().name);
            }
        });

        if (typers.length === 0) {
            typingIndicator.textContent = '';
        } else if (typers.length === 1) {
            typingIndicator.textContent = `${typers[0]} is typing...`;
        } else {
            typingIndicator.textContent = `${typers.length} people are typing...`;
        }
    });
    
    // 3. Muted Users Listener (Unchanged)
    MUTED_USERS_REF.on('value', snapshot => {
        mutedUserIds = snapshot.val() || {}; 
        console.log("Muted users updated:", Object.keys(mutedUserIds));
    });
}


function setupRoomPresenceListener() {
    // Detach old listener
    if (roomPresenceListener) totalOnlineRef.off('value', roomPresenceListener);

    // This listener watches the global presence list and filters by the current room
    roomPresenceListener = totalOnlineRef.on('value', snapshot => {
        let roomUsers = [];
        let roomCount = 0;
        userMap = {}; // Reset user map for current room
        
        snapshot.forEach(child => {
            const user = child.val();
            const uid = child.key;

            userMap[user.name] = uid; // Populate user map

            if (user.room === currentRoomId) {
                roomUsers.push({ id: uid, name: user.name });
                roomCount++;
            }
        });

        // Update UI Counts
        roomUserVal.textContent = roomCount;
        
        // Update User List (Unchanged logic)
        userList.innerHTML = '';
        roomUsers.forEach(user => {
            const item = document.createElement('div');
            
            const isMuted = !!mutedUserIds[user.id];

            item.className = 'user-item' + (isMuted ? ' muted-user' : '');

            const icon = document.createElement('i');
            icon.className = 'fas fa-circle';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = user.name + (user.id === userId ? ' (You)' : '') + (isMuted ? ' (Muted)' : '');
            
            item.appendChild(icon);
            item.appendChild(nameSpan);

            // Admin Mute/Unmute Button (Unchanged logic)
            if (isAdmin && user.id !== userId) { 
                const muteBtn = document.createElement('button');
                muteBtn.className = 'action-btn';
                muteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
                muteBtn.style.marginLeft = 'auto'; 
                muteBtn.style.backgroundColor = isMuted ? '#2ecc71' : '#e74c3c'; 
                muteBtn.onclick = () => toggleMute(user.id, user.name, isMuted);
                item.appendChild(muteBtn);
            }

            userList.appendChild(item);
        });
    });
}

// üî• NEW: Private Message Listener (Corrected)
function setupPrivateMessageListener() {
    // Detach existing listener if any
    privateMessageRef.child(userId).off(); 
    
    // Listener for messages SENT TO the current user (recipient is 'userId')
    // We use 'child_added' and 'child_removed' to handle real-time changes
    privateMessageRef.child(userId).on('child_added', renderMessage);

    privateMessageRef.child(userId).on('child_removed', snap => {
        const key = snap.key;
        const el = document.getElementById(key);
        if (el) {
            el.remove();
            chat.scrollTop = chat.scrollHeight;
        }
    });
}


// --- ROOM CONTROL LOGIC (Unchanged) ---

function setupRoomConnection(roomId) {
    if (chatListener) {
        currentRoomRef.off('child_added', chatListener);
        currentRoomRef.off('child_removed');
    }
    if (chatEditListener) {
        currentRoomRef.off('child_changed', chatEditListener);
    }
    
    if (userId) typingRef.child(currentRoomId).child(userId).remove(); 
    chat.innerHTML = ''; 


    currentRoomId = roomId.toLowerCase().replace(/[^a-z0-9-]/g, ''); 
    if (!currentRoomId) currentRoomId = 'global';
    
    currentRoomRef = db.ref(`rooms/${currentRoomId}`);
    
    roomDisplay.textContent = `Room: #${currentRoomId}`;
    roomIdHeader.textContent = currentRoomId;

    chatListener = currentRoomRef.limitToLast(100).on("child_added", renderMessage);
    chatEditListener = currentRoomRef.on("child_changed", updateMessage);

    currentRoomRef.on("child_removed", snap => {
        const key = snap.key;
        const el = document.getElementById(key);
        if (el) {
            el.remove();
            chat.scrollTop = chat.scrollHeight;
        }
    });

    setupPresence();
    setupRoomPresenceListener();
    setupGlobalListeners(); 

    console.log(`Connected to room: ${currentRoomId}`);
}

function joinRoom() {
    const newRoom = roomInput.value.trim();
    if (newRoom && newRoom !== currentRoomId) {
        setupRoomConnection(newRoom);
        roomInput.value = ''; 
    } else if (newRoom === currentRoomId) {
        console.log("Already in this room.");
        roomInput.value = ''; 
    }
}

function toggleUserList() {
    userListContainer.classList.toggle('active');
}


// --- EMOJI, TYPING LOGIC (Unchanged) ---

const emojis = [
'üòÄ','üòÅ','üòÇ','ü§£','üòÉ','üòÑ','üòÖ','üòÜ','üòâ','üòä',
'üòã','üòé','üòç','üòò','ü•∞','üòó','üòô','üòö','üôÇ','ü§ó',
'ü§©','ü§î','ü´¢','ü§´','ü§≠','ü´°','ü§®','üòê','üòë','üò∂',
'ü´•','üò∂‚Äçüå´Ô∏è','üôÑ','üòè','üò£','üò•','üòÆ','ü§ê','üòØ','üò™',
'üò´','ü•±','üò¥','üòå','üòõ','üòú','üòù','ü§§','üòí','üòì',
'üòî','üòï','ü´§','üôÉ','ü´†','ü´®','üò≤','‚òπÔ∏è','üôÅ','üòñ',
'üòû','üòü','üò§','üò¢','üò≠','üò¶','üòß','üò®','üò©','üò¨',
'üòÆ‚Äçüí®','üò∞','üò±','ü•µ','ü•∂','üò≥','ü§Ø','üòµ','üòµ‚Äçüí´',
'ü•¥','üò†','üò°','ü§¨','üò∑','ü§í','ü§ï','ü§¢','ü§Æ','ü§ß',
'üòá','ü•≥','ü•∏','üòà','üëø','ü§†','ü§ë','ü§ì','üòº','üôÄ',
'üòø','üòπ','üòª','üòæ','üò∫','üò∏','ü§°','üíÄ','‚ò†Ô∏è','üëª',
'üëΩ','ü§ñ','üéÉ','üí©','üëã','ü§ö','üñêÔ∏è','‚úã','üññ','üëå','ü§å','ü§è','‚úåÔ∏è','ü§û',
'ü´∞','ü§ü','ü§ò','ü§ô','üëà','üëâ','üëÜ','üñï','üëá','‚òùÔ∏è',
'üëç','üëé','‚úä','üëä','ü§õ','ü§ú','üëè','üôå','ü´∂','üôè',
'üíÖ','ü§ù','ü´±','ü´≤','ü´≥','ü´¥','üëÇ','ü¶ª','üëÉ','üß†',
'üëÄ','üëÅÔ∏è','üëÖ','üëÑ','ü´¶','üë∂','üßí','üë¶','üëß','üßë',
'üë®','üë©','üßì','üë¥','üëµ','üëÆ','üïµÔ∏è','üíÇ','ü•∑','üë∑',
'ü§¥','üë∏','üë≥','üßï','ü§µ','üë∞','ü´Ö','ü´É','ü´Ñ','ü§±',
'üëº','üéÖ','ü§∂','üßô','üßö','üßõ','üßú','üßù','üßû','üßü','üê∂','üê±','üê≠','üêπ','üê∞','ü¶ä','üêª','üêº','üêª‚Äç‚ùÑÔ∏è','üê®',
'üêØ','ü¶Å','üêÆ','üê∑','üê∏','üêµ','üôà','üôâ','üôä','üêí',
'üêî','üêß','üê¶','ü¶Ü','ü¶Ö','ü¶â','ü¶á','üê∫','üêó','üê¥',
'ü¶Ñ','üêù','ü™±','üêõ','ü¶ã','üêå','üêû','ü™∞','ü™≤','ü™≥',
'ü¶ü','üêú','üï∑Ô∏è','ü¶Ç','üê¢','üêç','ü¶é','ü¶ñ','ü¶ï','üêô',
'ü¶ë','ü¶ê','ü¶û','ü¶Ä','üê°','üê†','üêü','üê¨','üê≥','üêã',
'ü¶à','üêä','ü¶≠','ü¶¶','ü¶•','üêò','ü¶è','ü¶õ','ü¶í','ü¶ò',
'ü¶¨','üêÑ','üêé','üêñ','üêè','üêê','ü¶ô','ü¶å','üêï','üê©',
'ü¶Æ','üêï‚Äçü¶∫','üêà','üêà‚Äç‚¨õ','üêì','ü¶É','ü¶ö','ü¶ú','ü¶¢',
'ü™ø','ü¶©','üêÄ','üêÅ','ü¶´','ü¶î','üå≤','üå≥','üå¥','üåµ',
'üåæ','üåø','üçÄ','üçÅ','üçÇ','üçÉ','üåª','üåπ','üå∑','üåº','üçé','üçê','üçä','üçã','üçå','üçâ','üçá','üçì','ü´ê','üçà',
'üçí','üçë','ü•≠','üçç','ü••','ü•ù','üçÖ','üçÜ','ü•ë','ü•¶',
'ü•¨','ü•í','üå∂Ô∏è','ü´ë','üåΩ','ü•ï','ü´í','üßÑ','üßÖ','ü•î',
'üçû','ü•ê','ü•ñ','ü•®','ü•Ø','ü•û','üßá','üßÄ','üçñ','üçó',
'ü•©','ü•ì','üçî','üçü','üçï','üå≠','ü•™','üåÆ','üåØ','ü´î',
'ü•ô','üßÜ','ü•ö','üç≥','ü•ò','üç≤','ü´ï','ü•£','ü•ó','üçø',
'üßà','üßÇ','ü•´','üç±','üçò','üçô','üçö','üçõ','üçú','üçù',
'üç†','üç¢','üç£','üç§','üç•','ü•Æ','üç°','ü•ü','ü•†','ü•°',
'ü¶™','üç¶','üçß','üç®','üç©','üç™','üéÇ','üç∞','üßÅ','ü•ß',
'üç´','üç¨','üç≠','üçÆ','üçØ','üçº','ü•õ','‚òï','ü´ñ','üçµ',
'üßÉ','ü•§','üßã','üç∫','üçª','ü•Ç','üç∑','ü•É','üç∏','üçπ',
'üßâ','üçæ','‚öΩ','üèÄ','üèà','‚öæ','üéæ','üèê','üèâ','ü•è','üé±','üèì',
'üè∏','ü•Ö','‚õ≥','ü™Å','üé£','ü§ø','ü•ä','ü•ã','üéΩ','üõπ',
'üõº','üõ∑','‚õ∑Ô∏è','üèÇ','ü™Ç','üèãÔ∏è','ü§º','ü§∏','‚õπÔ∏è',
'ü§∫','üèåÔ∏è','üèá','üßò','üèÑ','üèä','üö¥','üöµ','üéÆ','üïπÔ∏è',
'üé≤','üß©','üé≠','üé®','üé§','üéß','üéº','üé∑','üé∏','üéπ',
'ü•Å','üì±','üíª','üñ•Ô∏è','‚å®Ô∏è','üñ±Ô∏è','üì∑','üì∏','üé•','üìΩÔ∏è',
'üìû','‚òéÔ∏è','üì∫','üìª','üß≠','‚è∞','‚åö','üîã','ü™´','üí°',
'üî¶','üïØÔ∏è','üßØ','üõ¢Ô∏è','üí∏','üí∞','üí≥','üíé','‚öôÔ∏è','üîß',
'üî®','üß∞','üî©','üß≤','üß™','üß´','üß¨','üî¨','üî≠','üì°',
'üìö','üìñ','‚úèÔ∏è','üñäÔ∏è','üìå','üìç','üìé','üóÇÔ∏è','üóëÔ∏è'
];

function populateEmojis() {
    emojis.forEach(emoji => {
        const span = document.createElement('span');
        span.className = 'emoji';
        span.textContent = emoji;
        span.onclick = () => insertEmoji(emoji);
        emojiPanel.appendChild(span);
    });
}

function insertEmoji(emoji) {
    messageInput.value += emoji;
    messageInput.focus();
    emojiPanel.classList.remove('active');
    sendTypingStatus(true); 
}

function toggleEmojiPanel() {
    emojiPanel.classList.toggle('active');
}

let typingTimeout = null;

function sendTypingStatus(isTyping) {
    if (!userId || !userName) return; 

    const userTypingRef = typingRef.child(currentRoomId).child(userId);

    if (!userName) return; 

    if (isTyping) {
        userTypingRef.set({ name: userName }); 
        
        if (typingTimeout) clearTimeout(typingTimeout);

        typingTimeout = setTimeout(() => {
            userTypingRef.remove();
            typingTimeout = null;
        }, 3000); 
        
    } else {
        userTypingRef.remove();
        if (typingTimeout) clearTimeout(typingTimeout);
    }
}

function handleInputKey(event) {
    if (event.key === 'Enter') {
        send();
    } else {
        if (messageInput.value.trim().length > 0 || event.key.length === 1) {
            sendTypingStatus(true);
        }
    }
}


// --- CHAT SEND LOGIC (Updated to handle /whisper) ---

function send(){
    let name = userName; 
    let msg = messageInput.value.trim();
    
    if (!name) {
        showNameModal();
        return;
    }
    
    if (!userId) {
        console.error("Authentication error. Please refresh.");
        return;
    }
    
    setupPresence(); 

    if(!msg) return;

    if (msg.length > MAX_MESSAGE_LENGTH) {
        alert(`Message is too long. Maximum length is ${MAX_MESSAGE_LENGTH} characters.`);
        messageInput.focus();
        return;
    }

    if (checkRateLimit()) {
        alert(`Please slow down! You can send up to ${MAX_MESSAGES_IN_WINDOW} messages every ${TIME_WINDOW_MS / 1000} seconds.`);
        messageInput.value = "";
        sendTypingStatus(false);
        return;
    }

    // üî• NEW: Check for whisper command: /whisper "Username" Message
    const whisperRegex = /^\/whisper\s+"([^"]+)"\s+(.+)$/i;
    const match = msg.match(whisperRegex);

    if (match) {
        const targetUsername = match[1];
        const privateMsg = match[2].trim();
        const targetUserId = userMap[targetUsername]; // Look up UID from map

        if (!targetUserId) {
            alert(`User "${targetUsername}" not found. Check the spelling (case-sensitive) or if they are online.`);
            messageInput.value = ""; // Clear message input
            sendTypingStatus(false);
            return;
        }

        if (targetUserId === userId) {
            alert("You cannot whisper to yourself.");
            messageInput.value = ""; // Clear message input
            sendTypingStatus(false);
            return;
        }

        if (privateMsg.length === 0) {
            alert("Whisper message cannot be empty.");
            messageInput.value = ""; // Clear message input
            sendTypingStatus(false);
            return;
        }

        const messageData = {
            name: name,
            msg: privateMsg,
            userId: userId,
            time: Date.now(),
            recipientId: targetUserId,
            recipientName: targetUsername,
            private: true 
        };

        // 1. Send to the recipient's private queue
        const recipientPushRef = privateMessageRef.child(targetUserId).push(messageData);
        const privateMessageKey = recipientPushRef.key;

        // 2. Send to the sender's own private queue using the SAME key so they see it
        // This ensures the sender and recipient have the same message ID for display/deletion
        privateMessageRef.child(userId).child(privateMessageKey).set(messageData);

        console.log(`Whisper sent to ${targetUsername} with key ${privateMessageKey}`);

    } else {
        // Normal public message
        currentRoomRef.push({
            name,
            msg,
            userId, 
            time: Date.now(),
            room: currentRoomId // Add room for context
        });
    }


    messageInput.value = "";
    emojiPanel.classList.remove('active'); 
    sendTypingStatus(false);
}

// --- MESSAGE RENDERING (Completed with update and render logic) ---

/**
 * Creates and attaches a message element to the chat.
 * @param {object} snap The Firebase DataSnapshot.
 */
function renderMessage(snap) {
    const key = snap.key;
    const m = snap.val();
    
    // Check if the message is for the current room or a private message to/from this user
    const isPublicMessage = !m.private && m.room === currentRoomId;
    const isPrivateMessage = m.private && (m.userId === userId || m.recipientId === userId);

    if (!isPublicMessage && !isPrivateMessage) {
        return;
    }
    
    // Skip rendering if sender is muted and we are not the sender
    if (mutedUserIds[m.userId] && m.userId !== userId) {
        return;
    }
    
    let div = document.getElementById(key);
    if (div) return; // Prevent duplicates

    div = document.createElement('div');
    div.id = key;
    div.className = 'msg';
    
    // Add classes
    if (m.userId === userId) {
        div.classList.add('me');
    }
    if (isAdmin) {
        div.classList.add('admin');
    }
    if (isPrivateMessage) {
        div.classList.add('private');
    }
    
    // Action Buttons Container
    const actionButtons = document.createElement('div');
    actionButtons.className = 'action-buttons';
    
    // Delete Button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'action-btn delete-btn';
    deleteBtn.textContent = 'Delete';
    deleteBtn.onclick = () => deleteMessage(key, m.private);
    actionButtons.appendChild(deleteBtn);
    
    // Edit Button (Only for own messages)
    if (m.userId === userId && !m.private) { // Allow editing public messages only
        const editBtn = document.createElement('button');
        editBtn.className = 'action-btn edit-btn';
        editBtn.textContent = 'Edit';
        editBtn.onclick = () => editMessage(key, m.msg);
        actionButtons.appendChild(editBtn);
    }
    
    // Bubble Wrapper
    const bubbleWrapper = document.createElement('div');
    bubbleWrapper.className = 'bubble-wrapper';
    
    // Name Element
    const nameSpan = document.createElement('div');
    nameSpan.className = 'name';
    if (isPrivateMessage) {
        const sender = m.userId === userId ? 'You' : m.name;
        const recipient = m.recipientId === userId ? 'You' : m.recipientName;
        nameSpan.innerHTML = `<span class="whisper-name">${sender}</span> &gt; <span class="whisper-name">${recipient}</span>`;
    } else {
        nameSpan.textContent = m.name;
    }

    // Bubble Element
    const bubble = document.createElement('div');
    bubble.className = 'bubble';
    bubble.textContent = m.msg;
    
    // Edit Input Wrapper (Initially hidden)
    const editInputWrapper = document.createElement('div');
    editInputWrapper.className = 'edit-input-wrapper';
    editInputWrapper.id = `edit-wrapper-${key}`;
    editInputWrapper.style.display = 'none';

    const editInput = document.createElement('input');
    editInput.id = `edit-input-${key}`;
    editInput.value = m.msg;

    const saveButton = document.createElement('button');
    saveButton.textContent = 'Save';
    saveButton.onclick = () => saveEdit(key, bubble.id);

    editInputWrapper.appendChild(editInput);
    editInputWrapper.appendChild(saveButton);

    // Assembly
    bubbleWrapper.appendChild(nameSpan);
    bubbleWrapper.appendChild(bubble);
    bubbleWrapper.appendChild(editInputWrapper);

    // Order elements based on 'me'
    if (m.userId === userId) {
        div.appendChild(actionButtons);
        div.appendChild(bubbleWrapper);
    } else {
        div.appendChild(bubbleWrapper);
        div.appendChild(actionButtons);
    }

    chat.appendChild(div);
    chat.scrollTop = chat.scrollHeight;
}

/**
 * Updates an existing message element when the data changes in Firebase.
 * @param {object} snap The Firebase DataSnapshot.
 */
function updateMessage(snap) {
    const key = snap.key;
    const m = snap.val();
    const messageDiv = document.getElementById(key);
    
    if (messageDiv) {
        // Find the bubble element inside the messageDiv (assuming it's the second child in the wrapper)
        const bubbleWrapper = messageDiv.querySelector('.bubble-wrapper');
        if (bubbleWrapper) {
            const bubble = bubbleWrapper.querySelector('.bubble');
            if (bubble) {
                // Check if the edit input is active
                const editInputWrapper = document.getElementById(`edit-wrapper-${key}`);
                if (editInputWrapper && editInputWrapper.style.display !== 'none') {
                    // If the edit is active, do not overwrite the bubble's content
                    // The user is currently editing or has just finished.
                    // Instead, we just hide the edit wrapper in case the update was from a successful save.
                    editInputWrapper.style.display = 'none';
                } else {
                    bubble.textContent = m.msg;
                }
            }
        }
    }
}


// --- ADMIN FUNCTIONS ---

function toggleAdminMode() {
    if (userId === ADMIN_UID) {
        isAdmin = !isAdmin;
        adminBanner.style.display = isAdmin ? 'flex' : 'none';
        console.log(`Admin mode set to: ${isAdmin}`);
        // Re-render user list to show/hide admin buttons
        setupRoomPresenceListener(); 
        // Force a re-render of chat to apply admin class if needed
        chat.innerHTML = '';
        setupRoomConnection(currentRoomId);
    } else {
        alert("You are not authorized to use Admin Mode.");
    }
}

/**
 * Shows the confirmation modal for clearing the chat.
 */
function showConfirmClear() {
    if (!isAdmin) return;
    clearRoomNameSpan.textContent = currentRoomId;
    clearConfirmModalOverlay.style.display = 'flex';
}

/**
 * üî• FIX: Clears all messages from the current room.
 */
function confirmClear() {
    if (!isAdmin) {
        alert("Authorization failed.");
        return;
    }
    
    // 1. Hide the modal
    clearConfirmModalOverlay.style.display = 'none';

    // 2. Perform the delete operation on the current room
    currentRoomRef.set(null)
        .then(() => {
            console.log(`Successfully cleared all messages in room #${currentRoomId}`);
            alert(`SUCCESS! All messages in room #${currentRoomId} have been cleared.`);
            chat.innerHTML = ''; // Clear local chat display
        })
        .catch(error => {
            console.error("FAILED to clear messages:", error);
            alert(`FAILED TO CLEAR MESSAGES: ${error.message}`);
        });

    // We don't clear the input field as it wasn't used, but the `catch` block 
    // is essential for providing feedback if the delete fails (e.g., due to security rules).
}

/**
 * Toggles a user's mute status.
 */
function toggleMute(targetUserId, targetUsername, isMuted) {
    if (!isAdmin) return;

    const userMuteRef = MUTED_USERS_REF.child(targetUserId);

    if (isMuted) {
        userMuteRef.remove()
            .then(() => alert(`User ${targetUsername} has been UNMUTED.`))
            .catch(e => console.error("Unmute failed:", e));
    } else {
        userMuteRef.set({ name: targetUsername, mutedBy: userId })
            .then(() => alert(`User ${targetUsername} has been MUTED.`))
            .catch(e => console.error("Mute failed:", e));
    }
}


// --- MESSAGE ACTION FUNCTIONS ---

function deleteMessage(key, isPrivate) {
    const isMe = document.getElementById(key).classList.contains('me');
    if (!isAdmin && !isMe) return;

    if (!confirm(`Are you sure you want to delete this message (ID: ${key})?`)) return;

    let targetRef;
    if (isPrivate) {
        // For private messages, delete only from the current user's private queue
        targetRef = privateMessageRef.child(userId).child(key);
    } else {
        // For public messages, delete from the room
        targetRef = currentRoomRef.child(key);
    }

    targetRef.remove()
        .then(() => console.log(`Message ${key} deleted successfully.`))
        .catch(error => alert(`Deletion failed: ${error.message}`));
}

function editMessage(key, currentMsg) {
    const messageDiv = document.getElementById(key);
    const bubble = messageDiv.querySelector('.bubble');
    const editWrapper = document.getElementById(`edit-wrapper-${key}`);
    const editInput = document.getElementById(`edit-input-${key}`);
    
    // Only allow editing if it's the user's own message and not currently editing
    if (messageDiv.classList.contains('me') && editWrapper.style.display === 'none') {
        bubble.style.display = 'none';
        editInput.value = currentMsg; // Set current message for editing
        editWrapper.style.display = 'flex';
        editInput.focus();
        // Hide action buttons while editing
        messageDiv.querySelector('.action-buttons').style.opacity = '0';
    }
}

function saveEdit(key) {
    const messageDiv = document.getElementById(key);
    const editWrapper = document.getElementById(`edit-wrapper-${key}`);
    const editInput = document.getElementById(`edit-input-${key}`);
    
    const newMsg = editInput.value.trim();

    if (!newMsg) {
        alert("Edited message cannot be empty.");
        editInput.focus();
        return;
    }

    if (newMsg.length > MAX_MESSAGE_LENGTH) {
        alert(`Message is too long. Max is ${MAX_MESSAGE_LENGTH} characters.`);
        editInput.focus();
        return;
    }

    // Update the message in Firebase
    currentRoomRef.child(key).update({ msg: newMsg, edited: Date.now() })
        .then(() => {
            console.log(`Message ${key} edited successfully.`);
            // The 'updateMessage' listener handles the actual UI change
            // Fallback: hide edit controls manually
            editWrapper.style.display = 'none';
            messageDiv.querySelector('.bubble').style.display = 'inline-block';
            messageDiv.querySelector('.action-buttons').style.opacity = '1';
        })
        .catch(error => alert(`Edit failed: ${error.message}`));
}

// --- INITIALIZATION ---
window.onload = setupAuthAndInit;
</script>

</body>
</html>
